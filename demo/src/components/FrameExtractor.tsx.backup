/**
 * BSD 3-Clause License
 *
 * * Copyright (c) 2025, SCTG DÃ©veloppement
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation
 *  and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *  contributors may be used to endorse or promote products derived from
 *  this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import type { FC } from 'react';
import { useState, useCallback, useEffect, useRef } from 'react';
import {
    Table,
    TableHeader,
    TableColumn,
    TableBody,
    TableRow,
    TableCell,
} from '@heroui/table';
import {
    Button,
} from '@heroui/button';
import {
    Card,
    CardBody,
    CardHeader,
} from '@heroui/card';
import {
    Progress,
} from '@heroui/progress';
import {
    Chip,
} from '@heroui/chip';
import {
    Badge,
} from '@heroui/badge';
import {
    Alert,
} from '@heroui/alert';

// Import libwebm-js
import createLibWebM from '@sctg/libwebm-js';


/**
 * Props for the FrameExtractor component
 */
interface FrameExtractorProps {
  /** Callback function called when an error occurs */
  onError: (error: string) => void;
  /** Callback function called when loading state changes */
  onLoading: (loading: boolean) => void;
}

/**
 * Represents information about an extracted frame
 */
interface ExtractedFrame {
  /** Frame number */
  frameNumber: number;
  /** Timestamp in nanoseconds */
  timestampNs: number;
  /** Frame data size in bytes */
  dataSize: number;
  /** Whether this is a keyframe */
  isKeyframe: boolean;
  /** Frame type (video/audio) */
  frameType: 'video' | 'audio';
}

/**
 * Component for demonstrating WebM frame extraction capabilities
 * Shows how to extract individual frames from WebM files with timing information
 */
export const FrameExtractor = ({
  onError,
  onLoading
}: FrameExtractorProps) => {
  const [frames, setFrames] = useState<ExtractedFrame[]>([]);
  const [isExtracting, setIsExtracting] = useState(false);
  const [extractionProgress, setExtractionProgress] = useState(0);
  const [libwebm, setLibwebm] = useState<any>(null);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isWorkerMode, setIsWorkerMode] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Initialize libwebm-js on component mount
  useEffect(() => {
    const initializeLibWebM = async () => {
      try {
        const libwebmInstance = await createLibWebM();
        setLibwebm(libwebmInstance);
      } catch (error) {
        onError(`Failed to initialize libwebm-js: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    };

    initializeLibWebM();
  }, [onError]);

  /**
   * Extracts frames from a WebM file using libwebm-js
   */
  const extractFrames = useCallback(async () => {
    if (!libwebm) {
      onError('libwebm-js is not initialized');
      return;
    }

    if (!selectedFile) {
      onError('Please select a WebM file first');
      return;
    }

    setIsExtracting(true);
    setExtractionProgress(0);
    setFrames([]);
    onLoading(true);

    try {
      // Read selected file as ArrayBuffer
      const arrayBuffer = await selectedFile.arrayBuffer();
      const buffer = new Uint8Array(arrayBuffer);

      // Create parser directly from buffer
      const parser = libwebm.WebMParser.createFromBuffer(buffer);

      // Check if we're in worker mode by trying to call parseHeaders
      const isWorkerMode = typeof parser.parseHeaders !== 'function';
      setIsWorkerMode(isWorkerMode);

      if (!isWorkerMode) {
        // In full mode, parse headers
        parser.parseHeaders();
      }
      // In worker mode, parsing is already done during WebMParserWorker construction

      // Extract frames from the first video track
      const trackCount = parser.getTrackCount();
      let videoTrackIndex = -1;

      // Find the first video track
      for (let i = 0; i < trackCount; i++) {
        const trackInfo = parser.getTrackInfo(i);
        if (trackInfo.trackType === 1) { // VIDEO
          videoTrackIndex = i;
          break;
        }
      }

      if (videoTrackIndex === -1) {
        throw new Error('No video track found in the WebM file');
      }

      // Extract frames from the video track
      const extractedFrames: ExtractedFrame[] = [];
      const maxFrames = 20; // Limit to 20 frames for demo

      let frameCount = 0;
      let frame: any = null;

      // Read frames one by one using readNextVideoFrame
      do {
        frame = parser.readNextVideoFrame(videoTrackIndex);

        if (frame && frameCount < maxFrames) {
          const extractedFrame: ExtractedFrame = {
            frameNumber: frameCount + 1,
            timestampNs: frame.timestampNs,
            dataSize: frame.data.length,
            isKeyframe: frame.isKeyframe,
            frameType: 'video'
          };

          extractedFrames.push(extractedFrame);
          frameCount++;

          // Update progress
          setExtractionProgress((frameCount / maxFrames) * 100);
          setFrames([...extractedFrames]);

          // Small delay to show progress
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      } while (frame && frameCount < maxFrames);

      onLoading(false);
    } catch (error) {
      onError(`Frame extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsExtracting(false);
      onLoading(false);
    }
  }, [libwebm, selectedFile, onError, onLoading]);

  /**
   * Handles file selection
   */
  const handleFileSelect = useCallback((event: Event) => {
    const target = event.target as HTMLInputElement;
    const file = target.files?.[0];
    if (file) {
      if (!file.name.toLowerCase().endsWith('.webm')) {
        onError('Please select a WebM file (.webm)');
        return;
      }
      setSelectedFile(file);
    }
  }, [onError]);

  /**
   * Opens file selector
   */
  const openFileSelector = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  /**
   * Clears the selected file
   */
  const clearFile = useCallback(() => {
    setSelectedFile(null);
    setFrames([]);
    setExtractionProgress(0);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, []);

  /**
   * Clears the extracted frames and selected file
   */
  const clearFrames = useCallback(() => {
    clearFile();
  }, [clearFile]);

  /**
   * Formats timestamp from nanoseconds to human-readable format
   * @param timestampNs - Timestamp in nanoseconds
   * @returns Formatted timestamp string
   */
  const formatTimestamp = (timestampNs: number): string => {
    const seconds = timestampNs / 1000000000;
    return `${seconds.toFixed(3)}s`;
  };

  /**
   * Formats data size in human-readable format
   * @param bytes - Size in bytes
   * @returns Formatted size string
   */
  const formatDataSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  /**
   * Gets the appropriate color for frame type
   * @param frameType - The type of frame
   * @returns Color variant for the chip
   */
  const getFrameTypeColor = (frameType: 'video' | 'audio'): "primary" | "secondary" | "success" | "warning" | "danger" => {
    return frameType === 'video' ? 'primary' : 'secondary';
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <h3 className="text-xl font-semibold">Frame Extraction</h3>
        </CardHeader>
        <CardBody className="space-y-4">
          {/* Action Buttons */}
          <div className="flex gap-2">
            {!selectedFile ? (
              <Button
                color="primary"
                onClick={openFileSelector}
              >
                Select WebM File
              </Button>
            ) : (
              <Button
                color="primary"
                onClick={extractFrames}
                isLoading={isExtracting}
                disabled={isExtracting || isWorkerMode}
              >
                {isExtracting ? 'Extracting...' : 'Extract Frames'}
              </Button>
            )}
            {(frames.length > 0 || selectedFile) && (
              <Button
                color="secondary"
                variant="flat"
                onClick={clearFrames}
                disabled={isExtracting}
              >
                Clear
              </Button>
            )}
          </div>

          {/* Selected File Info */}
          {selectedFile && (
            <div className="flex items-center gap-2 p-3 bg-blue-50 rounded-lg">
              <span className="text-sm text-blue-700">Selected file:</span>
              <span className="text-sm font-medium text-blue-900">{selectedFile.name}</span>
              <span className="text-xs text-blue-600">
                ({formatDataSize(selectedFile.size)})
              </span>
            </div>
          )}

          {/* Hidden file input */}
          <input
            ref={fileInputRef}
            type="file"
            accept=".webm"
            onChange={handleFileSelect}
            style={{ display: 'none' }}
          />

          {/* Extraction Progress */}
          {isExtracting && (
            <div className="space-y-2">
              <Progress
                value={extractionProgress}
                color="primary"
                className="w-full"
              />
              <p className="text-sm text-gray-600 text-center">
                Extracting frames... {Math.round(extractionProgress)}%
              </p>
            </div>
          )}

          {/* Frames Table */}
          {frames.length > 0 && (
            <Card>
              <CardBody>
                <div className="flex justify-between items-center mb-4">
                  <h4 className="font-semibold">Extracted Frames</h4>
                  <Badge color="primary" variant="flat">
                    {frames.length} frames
                  </Badge>
                </div>

                <Table aria-label="Extracted frames table">
                  <TableHeader>
                    <TableColumn>Frame #</TableColumn>
                    <TableColumn>Type</TableColumn>
                    <TableColumn>Timestamp</TableColumn>
                    <TableColumn>Size</TableColumn>
                    <TableColumn>Keyframe</TableColumn>
                  </TableHeader>
                  <TableBody>
                    {frames.map((frame) => (
                      <TableRow key={frame.frameNumber}>
                        <TableCell>
                          <Badge color="primary" variant="flat">
                            {frame.frameNumber}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <Chip
                            color={getFrameTypeColor(frame.frameType)}
                            variant="flat"
                            size="sm"
                          >
                            {frame.frameType.toUpperCase()}
                          </Chip>
                        </TableCell>
                        <TableCell>
                          <span className="font-mono text-sm">
                            {formatTimestamp(frame.timestampNs)}
                          </span>
                        </TableCell>
                        <TableCell>
                          <span className="font-mono text-sm">
                            {formatDataSize(frame.dataSize)}
                          </span>
                        </TableCell>
                        <TableCell>
                          {frame.isKeyframe ? (
                            <Chip color="success" variant="flat" size="sm">
                              â Keyframe
                            </Chip>
                          ) : (
                            <Chip color="default" variant="flat" size="sm">
                              Regular
                            </Chip>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </CardBody>
            </Card>
          )}

          {/* Statistics */}
          {frames.length > 0 && (
            <Card className="bg-green-50">
              <CardBody>
                <h4 className="font-semibold mb-3">Extraction Statistics</h4>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <div className="text-center">
                    <div className="text-2xl font-bold text-blue-600">
                      {frames.length}
                    </div>
                    <div className="text-sm text-gray-600">Total Frames</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-green-600">
                      {frames.filter(f => f.frameType === 'video').length}
                    </div>
                    <div className="text-sm text-gray-600">Video Frames</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-orange-600">
                      {frames.filter(f => f.frameType === 'audio').length}
                    </div>
                    <div className="text-sm text-gray-600">Audio Frames</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-purple-600">
                      {frames.filter(f => f.isKeyframe).length}
                    </div>
                    <div className="text-sm text-gray-600">Keyframes</div>
                  </div>
                </div>

                <div className="mt-4 pt-4 border-t border-gray-200">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                    <div>
                      <span className="text-gray-600">Average frame size:</span>
                      <span className="font-medium ml-2">
                        {formatDataSize(Math.round(frames.reduce((sum, f) => sum + f.dataSize, 0) / frames.length))}
                      </span>
                    </div>
                    <div>
                      <span className="text-gray-600">Keyframe ratio:</span>
                      <span className="font-medium ml-2">
                        {((frames.filter(f => f.isKeyframe).length / frames.length) * 100).toFixed(1)}%
                      </span>
                    </div>
                  </div>
                </div>
              </CardBody>
            </Card>
          )}

          {/* Instructions */}
          {frames.length === 0 && !isExtracting && (
            <Alert
              color="primary"
              title="Frame Extraction"
              description="Extract individual frames from WebM files to analyze timing, data size, and keyframe information. This demonstrates the low-level access capabilities of libwebm-js."
            />
          )}

          {/* Worker mode warning */}
          {isWorkerMode && selectedFile && (
            <Alert
              color="warning"
              title="Limited Functionality"
              description="Running in worker mode. Frame extraction is not available. Please use the full libwebm-js library in a Node.js environment for complete functionality."
            />
          )}
        </CardBody>
      </Card>
    </div>
  );
};
